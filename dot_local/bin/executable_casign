#!/usr/bin/env bash
# @describe Create and sign (generate a certificate) host/user ssh keys
set -Eeuo pipefail
IFS=$'\n\t'
trap cleanup SIGINT SIGTERM ERR EXIT

# CA SK private key
CAKEY=$(mktemp)
echo '-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAASgAAABpzay1zc2
gtZWQyNTUxOUBvcGVuc3NoLmNvbQAAACC6PGKq9lFOkONI8HZnRLQbUiEftLQwsqXepWo6
M3TPUgAAAARzc2g6AAAA8Hde3Q53Xt0OAAAAGnNrLXNzaC1lZDI1NTE5QG9wZW5zc2guY2
9tAAAAILo8Yqr2UU6Q40jwdmdEtBtSIR+0tDCypd6lajozdM9SAAAABHNzaDohAAAAhKMA
WGDDo0UQYFnOk6qM8vJJ2ynxm8SfP3Iwmffpt6S0Mu8KZgnRlmZN/zS1hLQntU8fzZSdO0
94ib79fZGO++4lrYcTeqmmz5asPrR/T9Pbf8KbkZToOMVtTsNM8SS+L/1iTHwBTJ1mKSBi
ilNoRPoMsgJQN+2/7VtNGxq5ZWsRvA5UMwAAAAAAAAAIYXNAYmFtYmkBAgMEBQ==
-----END OPENSSH PRIVATE KEY-----' >$CAKEY

ROOTDIR=${ROOTDIR:-.}
[ -d $ROOTDIR ] || mkdir -p "$ROOTDIR"

cleanup() {
  trap - SIGINT SIGTERM ERR EXIT
  rm -f $CAKEY
}

# @cmd Create and sign a host key
# @option -k --key <key>         just sign the given key file
# @option -H --host <hostname>   host name
host() {
  HOST=${argc_host:-$(hostname)}
  [ -z "${argc_key:-}" ] && ssh-keygen -t ed25519 -C "root@$HOST" -f $ROOTDIR/ssh_host_ed25519
  ssh-keygen -s "$CAKEY" \
       -I "$HOST host key" \
       -V -1m:+3650d \
       -h \
       ${argc_key:-"$ROOTDIR/ssh_host_ed25519.pub"} && \
    echo $ROOTDIR/*-cert.pub |tr ' ' '\n' |xargs -L 1 ssh-keygen -L -f
}

# @cmd Create and sign a user key
# @option -k --key <key>                  just sign the given key file
# @option -i=`$(whoami)@$(hostname)` <ID> certificate identity
# @option -n=`$(whoami)` <p,p,...>        principals
user() {
  [ -v argc_key ] || ssh-keygen -f id_ed25519 -t ed25519
  # principals: must match user sysemd id on server hosts
  ssh-keygen -s "$CAKEY" \
      -I "$argc_i user key" \
      -n "$argc_n" \
      -V -1m:+3650d \
      ${argc_key:-id_ed25519.pub} && \
  ssh-keygen -L -f $(basename ${argc_key:-id_ed25519} .pub)-cert.pub
}

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
Create and sign (generate a certificate) host/user ssh keys

USAGE: casign <COMMAND>

COMMANDS:
  host  Create and sign a host key
  user  Create and sign a user key
EOF
    exit
}

_argc_version() {
    echo casign 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds="host, user"
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        host)
            _argc_index=$((_argc_index + 1))
            _argc_action=_argc_parse_host
            break
            ;;
        user)
            _argc_index=$((_argc_index + 1))
            _argc_action=_argc_parse_user
            break
            ;;
        help)
            local help_arg="${argc__args[$((_argc_index + 1))]:-}"
            case "$help_arg" in
            host)
                _argc_usage_host
                ;;
            user)
                _argc_usage_user
                ;;
            "")
                _argc_usage
                ;;
            *)
                _argc_die "error: invalid value \`$help_arg\` for \`<command>\`"$'\n'"  [possible values: $_argc_subcmds]"
                ;;
            esac
            ;;
        *)
            _argc_die "error: \`casign\` requires a subcommand but one was not provided"$'\n'"  [subcommands: $_argc_subcmds]"
            ;;
        esac
    done
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        _argc_usage
    fi
}

_argc_usage_host() {
    cat <<-'EOF'
Create and sign a host key

USAGE: casign host [OPTIONS]

OPTIONS:
  -k, --key <KEY>        just sign the given key file
  -H, --host <HOSTNAME>  host name
  -h, --help             Print help
EOF
    exit
}

_argc_parse_host() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage_host
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --key | -k)
            _argc_take_args "--key <KEY>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_key:-}" ]]; then
                argc_key="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--key\` cannot be used multiple times"
            fi
            ;;
        --host | -H)
            _argc_take_args "--host <HOSTNAME>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_host:-}" ]]; then
                argc_host="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--host\` cannot be used multiple times"
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=host
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage_host
        fi
    fi
}

_argc_usage_user() {
    cat <<-'EOF'
Create and sign a user key

USAGE: casign user [OPTIONS]

OPTIONS:
  -k, --key <KEY>  just sign the given key file
  -i <ID>          certificate identity [default: '`$(whoami)@$(hostname)`']
  -n <P,P,...>     principals [default: '`$(whoami)`']
  -h,  -help       Print help
EOF
    exit
}

_argc_parse_user() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage_user
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --key | -k)
            _argc_take_args "--key <KEY>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_key:-}" ]]; then
                argc_key="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--key\` cannot be used multiple times"
            fi
            ;;
        -i)
            _argc_take_args "-i <ID>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_i:-}" ]]; then
                argc_i="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`-i\` cannot be used multiple times"
            fi
            ;;
        -n)
            _argc_take_args "-n <P,P,...>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_n:-}" ]]; then
                argc_n="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`-n\` cannot be used multiple times"
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=user
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage_user
        fi
        if [[ -z "${argc_i:-}" ]]; then
            argc_i='`$(whoami)@$(hostname)`'
        fi
        if [[ -z "${argc_n:-}" ]]; then
            argc_n='`$(whoami)`'
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }
